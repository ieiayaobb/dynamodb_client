# Generated from C:/pyprojects/hackathon/src/parser\MySQLParser.g4 by ANTLR 4.5.3
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
        buf.write(u"O\u008a\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
        buf.write(u"\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30")
        buf.write(u"\t\30\4\31\t\31\4\32\t\32\3\2\3\2\5\2\67\n\2\3\3\3\3")
        buf.write(u"\3\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\5\5C\n\5\3\5\5\5F\n")
        buf.write(u"\5\3\6\3\6\3\6\3\7\3\7\3\b\3\b\3\t\3\t\3\n\3\n\3\n\5")
        buf.write(u"\nT\n\n\3\13\3\13\3\f\3\f\3\f\6\f[\n\f\r\f\16\f\\\3\r")
        buf.write(u"\3\r\3\16\3\16\5\16c\n\16\3\17\3\17\3\17\3\17\3\17\3")
        buf.write(u"\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\21\3\21")
        buf.write(u"\3\22\3\22\3\23\3\23\3\24\3\24\3\25\3\25\3\26\3\26\3")
        buf.write(u"\27\3\27\3\30\3\30\3\31\3\31\3\32\3\32\3\32\5\32\u0088")
        buf.write(u"\n\32\3\32\2\2\33\2\4\6\b\n\f\16\20\22\24\26\30\32\34")
        buf.write(u"\36 \"$&(*,.\60\62\2\4\4\2,/\61\62\4\2\13\r\60\60x\2")
        buf.write(u"\66\3\2\2\2\48\3\2\2\2\6:\3\2\2\2\b=\3\2\2\2\nG\3\2\2")
        buf.write(u"\2\fJ\3\2\2\2\16L\3\2\2\2\20N\3\2\2\2\22S\3\2\2\2\24")
        buf.write(u"U\3\2\2\2\26W\3\2\2\2\30^\3\2\2\2\32b\3\2\2\2\34d\3\2")
        buf.write(u"\2\2\36i\3\2\2\2 r\3\2\2\2\"t\3\2\2\2$v\3\2\2\2&x\3\2")
        buf.write(u"\2\2(z\3\2\2\2*|\3\2\2\2,~\3\2\2\2.\u0080\3\2\2\2\60")
        buf.write(u"\u0082\3\2\2\2\62\u0087\3\2\2\2\64\67\5\b\5\2\65\67\5")
        buf.write(u"\6\4\2\66\64\3\2\2\2\66\65\3\2\2\2\67\3\3\2\2\289\7K")
        buf.write(u"\2\29\5\3\2\2\2:;\7\5\2\2;<\5\f\7\2<\7\3\2\2\2=>\7\3")
        buf.write(u"\2\2>?\5\22\n\2?@\7\b\2\2@B\5\f\7\2AC\5\32\16\2BA\3\2")
        buf.write(u"\2\2BC\3\2\2\2CE\3\2\2\2DF\5\n\6\2ED\3\2\2\2EF\3\2\2")
        buf.write(u"\2F\t\3\2\2\2GH\7\n\2\2HI\5*\26\2I\13\3\2\2\2JK\7K\2")
        buf.write(u"\2K\r\3\2\2\2LM\7K\2\2M\17\3\2\2\2NO\7K\2\2O\21\3\2\2")
        buf.write(u"\2PT\5\24\13\2QT\5\26\f\2RT\5\30\r\2SP\3\2\2\2SQ\3\2")
        buf.write(u"\2\2SR\3\2\2\2T\23\3\2\2\2UV\7K\2\2V\25\3\2\2\2WZ\7K")
        buf.write(u"\2\2XY\7\64\2\2Y[\7K\2\2ZX\3\2\2\2[\\\3\2\2\2\\Z\3\2")
        buf.write(u"\2\2\\]\3\2\2\2]\27\3\2\2\2^_\7%\2\2_\31\3\2\2\2`c\5")
        buf.write(u"\34\17\2ac\5\36\20\2b`\3\2\2\2ba\3\2\2\2c\33\3\2\2\2")
        buf.write(u"de\7\t\2\2ef\5 \21\2fg\5,\27\2gh\5$\23\2h\35\3\2\2\2")
        buf.write(u"ij\7\t\2\2jk\5 \21\2kl\5,\27\2lm\5$\23\2mn\5.\30\2no")
        buf.write(u"\5\"\22\2op\5,\27\2pq\5&\24\2q\37\3\2\2\2rs\7K\2\2s!")
        buf.write(u"\3\2\2\2tu\7K\2\2u#\3\2\2\2vw\7K\2\2w%\3\2\2\2xy\7K\2")
        buf.write(u"\2y\'\3\2\2\2z{\7K\2\2{)\3\2\2\2|}\7K\2\2}+\3\2\2\2~")
        buf.write(u"\177\t\2\2\2\177-\3\2\2\2\u0080\u0081\t\3\2\2\u0081/")
        buf.write(u"\3\2\2\2\u0082\u0083\7\31\2\2\u0083\61\3\2\2\2\u0084")
        buf.write(u"\u0088\7\16\2\2\u0085\u0086\7\16\2\2\u0086\u0088\7\60")
        buf.write(u"\2\2\u0087\u0084\3\2\2\2\u0087\u0085\3\2\2\2\u0088\63")
        buf.write(u"\3\2\2\2\t\66BES\\b\u0087")
        return buf.getvalue()


class MySQLParser ( Parser ):

    grammarFileName = "MySQLParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"<INVALID>", u"'insert'", u"<INVALID>", 
                     u"<INVALID>", u"'values'", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"'xor'", 
                     u"'is'", u"'null'", u"'like'", u"'in'", u"'exists'", 
                     u"'all'", u"'any'", u"'true'", u"'false'", u"<INVALID>", 
                     u"<INVALID>", u"'between'", u"'regexp'", u"'+'", u"'-'", 
                     u"'~'", u"'|'", u"'&'", u"'^'", u"'binary'", u"'<<'", 
                     u"'>>'", u"'escape'", u"'*'", u"')'", u"'('", u"']'", 
                     u"'['", u"':'", u"'.*'", u"'='", u"'<'", u"'>'", u"'!='", 
                     u"'not'", u"'<='", u"'>='", u"';'", u"','", u"'.'", 
                     u"'collate'", u"'inner'", u"'outer'", u"'join'", u"'cross'", 
                     u"'using'", u"'index'", u"'key'", u"'order'", u"'group'", 
                     u"'by'", u"'for'", u"'use'", u"'ignore'", u"'partition'", 
                     u"'straight_join'", u"'natural'", u"'left'", u"'right'", 
                     u"'oj'", u"'on'" ]

    symbolicNames = [ u"<INVALID>", u"SELECT", u"INSERT", u"DESC", u"INTO", 
                      u"VALUES", u"FROM", u"WHERE", u"LIMIT", u"AND", u"OR", 
                      u"XOR", u"IS", u"NULL", u"LIKE", u"IN", u"EXISTS", 
                      u"ALL", u"ANY", u"TRUE", u"FALSE", u"DIVIDE", u"MOD", 
                      u"BETWEEN", u"REGEXP", u"PLUS", u"MINUS", u"NEGATION", 
                      u"VERTBAR", u"BITAND", u"POWER_OP", u"BINARY", u"SHIFT_LEFT", 
                      u"SHIFT_RIGHT", u"ESCAPE", u"ASTERISK", u"RPAREN", 
                      u"LPAREN", u"RBRACK", u"LBRACK", u"COLON", u"ALL_FIELDS", 
                      u"EQ", u"LTH", u"GTH", u"NOT_EQ", u"NOT", u"LET", 
                      u"GET", u"SEMI", u"COMMA", u"DOT", u"COLLATE", u"INNER", 
                      u"OUTER", u"JOIN", u"CROSS", u"USING", u"INDEX", u"KEY", 
                      u"ORDER", u"GROUP", u"BY", u"FOR", u"USE", u"IGNORE", 
                      u"PARTITION", u"STRAIGHT_JOIN", u"NATURAL", u"LEFT", 
                      u"RIGHT", u"OJ", u"ON", u"ID", u"INT", u"NEWLINE", 
                      u"WS", u"USER_VAR" ]

    RULE_stat = 0
    RULE_schema_name = 1
    RULE_desc_clause = 2
    RULE_select_clause = 3
    RULE_limit_clause = 4
    RULE_table_name = 5
    RULE_column_name = 6
    RULE_column_name_alias = 7
    RULE_column_list_clause = 8
    RULE_single_column = 9
    RULE_multi_column = 10
    RULE_all_column = 11
    RULE_where_clause = 12
    RULE_hash_expression = 13
    RULE_hash_range_expression = 14
    RULE_hash_key = 15
    RULE_range_key = 16
    RULE_hash_value = 17
    RULE_range_value = 18
    RULE_insert_value = 19
    RULE_limit_value = 20
    RULE_relational_op = 21
    RULE_expr_op = 22
    RULE_between_op = 23
    RULE_is_or_is_not = 24

    ruleNames =  [ u"stat", u"schema_name", u"desc_clause", u"select_clause", 
                   u"limit_clause", u"table_name", u"column_name", u"column_name_alias", 
                   u"column_list_clause", u"single_column", u"multi_column", 
                   u"all_column", u"where_clause", u"hash_expression", u"hash_range_expression", 
                   u"hash_key", u"range_key", u"hash_value", u"range_value", 
                   u"insert_value", u"limit_value", u"relational_op", u"expr_op", 
                   u"between_op", u"is_or_is_not" ]

    EOF = Token.EOF
    SELECT=1
    INSERT=2
    DESC=3
    INTO=4
    VALUES=5
    FROM=6
    WHERE=7
    LIMIT=8
    AND=9
    OR=10
    XOR=11
    IS=12
    NULL=13
    LIKE=14
    IN=15
    EXISTS=16
    ALL=17
    ANY=18
    TRUE=19
    FALSE=20
    DIVIDE=21
    MOD=22
    BETWEEN=23
    REGEXP=24
    PLUS=25
    MINUS=26
    NEGATION=27
    VERTBAR=28
    BITAND=29
    POWER_OP=30
    BINARY=31
    SHIFT_LEFT=32
    SHIFT_RIGHT=33
    ESCAPE=34
    ASTERISK=35
    RPAREN=36
    LPAREN=37
    RBRACK=38
    LBRACK=39
    COLON=40
    ALL_FIELDS=41
    EQ=42
    LTH=43
    GTH=44
    NOT_EQ=45
    NOT=46
    LET=47
    GET=48
    SEMI=49
    COMMA=50
    DOT=51
    COLLATE=52
    INNER=53
    OUTER=54
    JOIN=55
    CROSS=56
    USING=57
    INDEX=58
    KEY=59
    ORDER=60
    GROUP=61
    BY=62
    FOR=63
    USE=64
    IGNORE=65
    PARTITION=66
    STRAIGHT_JOIN=67
    NATURAL=68
    LEFT=69
    RIGHT=70
    OJ=71
    ON=72
    ID=73
    INT=74
    NEWLINE=75
    WS=76
    USER_VAR=77

    def __init__(self, input):
        super(MySQLParser, self).__init__(input)
        self.checkVersion("4.5.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class StatContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.StatContext, self).__init__(parent, invokingState)
            self.parser = parser

        def select_clause(self):
            return self.getTypedRuleContext(MySQLParser.Select_clauseContext,0)


        def desc_clause(self):
            return self.getTypedRuleContext(MySQLParser.Desc_clauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_stat

        def enterRule(self, listener):
            if hasattr(listener, "enterStat"):
                listener.enterStat(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStat"):
                listener.exitStat(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitStat"):
                return visitor.visitStat(self)
            else:
                return visitor.visitChildren(self)




    def stat(self):

        localctx = MySQLParser.StatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_stat)
        try:
            self.state = 52
            token = self._input.LA(1)
            if token in [MySQLParser.SELECT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 50
                self.select_clause()

            elif token in [MySQLParser.DESC]:
                self.enterOuterAlt(localctx, 2)
                self.state = 51
                self.desc_clause()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Schema_nameContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Schema_nameContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MySQLParser.ID, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_schema_name

        def enterRule(self, listener):
            if hasattr(listener, "enterSchema_name"):
                listener.enterSchema_name(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSchema_name"):
                listener.exitSchema_name(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitSchema_name"):
                return visitor.visitSchema_name(self)
            else:
                return visitor.visitChildren(self)




    def schema_name(self):

        localctx = MySQLParser.Schema_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_schema_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            self.match(MySQLParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Desc_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Desc_clauseContext, self).__init__(parent, invokingState)
            self.parser = parser

        def DESC(self):
            return self.getToken(MySQLParser.DESC, 0)

        def table_name(self):
            return self.getTypedRuleContext(MySQLParser.Table_nameContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_desc_clause

        def enterRule(self, listener):
            if hasattr(listener, "enterDesc_clause"):
                listener.enterDesc_clause(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitDesc_clause"):
                listener.exitDesc_clause(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitDesc_clause"):
                return visitor.visitDesc_clause(self)
            else:
                return visitor.visitChildren(self)




    def desc_clause(self):

        localctx = MySQLParser.Desc_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_desc_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 56
            self.match(MySQLParser.DESC)
            self.state = 57
            self.table_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Select_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Select_clauseContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(MySQLParser.SELECT, 0)

        def column_list_clause(self):
            return self.getTypedRuleContext(MySQLParser.Column_list_clauseContext,0)


        def FROM(self):
            return self.getToken(MySQLParser.FROM, 0)

        def table_name(self):
            return self.getTypedRuleContext(MySQLParser.Table_nameContext,0)


        def where_clause(self):
            return self.getTypedRuleContext(MySQLParser.Where_clauseContext,0)


        def limit_clause(self):
            return self.getTypedRuleContext(MySQLParser.Limit_clauseContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_select_clause

        def enterRule(self, listener):
            if hasattr(listener, "enterSelect_clause"):
                listener.enterSelect_clause(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSelect_clause"):
                listener.exitSelect_clause(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitSelect_clause"):
                return visitor.visitSelect_clause(self)
            else:
                return visitor.visitChildren(self)




    def select_clause(self):

        localctx = MySQLParser.Select_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_select_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 59
            self.match(MySQLParser.SELECT)
            self.state = 60
            self.column_list_clause()
            self.state = 61
            self.match(MySQLParser.FROM)
            self.state = 62
            self.table_name()
            self.state = 64
            _la = self._input.LA(1)
            if _la==MySQLParser.WHERE:
                self.state = 63
                self.where_clause()


            self.state = 67
            _la = self._input.LA(1)
            if _la==MySQLParser.LIMIT:
                self.state = 66
                self.limit_clause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Limit_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Limit_clauseContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LIMIT(self):
            return self.getToken(MySQLParser.LIMIT, 0)

        def limit_value(self):
            return self.getTypedRuleContext(MySQLParser.Limit_valueContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_limit_clause

        def enterRule(self, listener):
            if hasattr(listener, "enterLimit_clause"):
                listener.enterLimit_clause(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLimit_clause"):
                listener.exitLimit_clause(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitLimit_clause"):
                return visitor.visitLimit_clause(self)
            else:
                return visitor.visitChildren(self)




    def limit_clause(self):

        localctx = MySQLParser.Limit_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_limit_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self.match(MySQLParser.LIMIT)
            self.state = 70
            self.limit_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Table_nameContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Table_nameContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MySQLParser.ID, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_table_name

        def enterRule(self, listener):
            if hasattr(listener, "enterTable_name"):
                listener.enterTable_name(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTable_name"):
                listener.exitTable_name(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTable_name"):
                return visitor.visitTable_name(self)
            else:
                return visitor.visitChildren(self)




    def table_name(self):

        localctx = MySQLParser.Table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_table_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.match(MySQLParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Column_nameContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Column_nameContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MySQLParser.ID, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_column_name

        def enterRule(self, listener):
            if hasattr(listener, "enterColumn_name"):
                listener.enterColumn_name(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitColumn_name"):
                listener.exitColumn_name(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitColumn_name"):
                return visitor.visitColumn_name(self)
            else:
                return visitor.visitChildren(self)




    def column_name(self):

        localctx = MySQLParser.Column_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_column_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self.match(MySQLParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Column_name_aliasContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Column_name_aliasContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MySQLParser.ID, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_column_name_alias

        def enterRule(self, listener):
            if hasattr(listener, "enterColumn_name_alias"):
                listener.enterColumn_name_alias(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitColumn_name_alias"):
                listener.exitColumn_name_alias(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitColumn_name_alias"):
                return visitor.visitColumn_name_alias(self)
            else:
                return visitor.visitChildren(self)




    def column_name_alias(self):

        localctx = MySQLParser.Column_name_aliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_column_name_alias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 76
            self.match(MySQLParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Column_list_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Column_list_clauseContext, self).__init__(parent, invokingState)
            self.parser = parser

        def single_column(self):
            return self.getTypedRuleContext(MySQLParser.Single_columnContext,0)


        def multi_column(self):
            return self.getTypedRuleContext(MySQLParser.Multi_columnContext,0)


        def all_column(self):
            return self.getTypedRuleContext(MySQLParser.All_columnContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_column_list_clause

        def enterRule(self, listener):
            if hasattr(listener, "enterColumn_list_clause"):
                listener.enterColumn_list_clause(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitColumn_list_clause"):
                listener.exitColumn_list_clause(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitColumn_list_clause"):
                return visitor.visitColumn_list_clause(self)
            else:
                return visitor.visitChildren(self)




    def column_list_clause(self):

        localctx = MySQLParser.Column_list_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_column_list_clause)
        try:
            self.state = 81
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 78
                self.single_column()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 79
                self.multi_column()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 80
                self.all_column()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Single_columnContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Single_columnContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MySQLParser.ID, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_single_column

        def enterRule(self, listener):
            if hasattr(listener, "enterSingle_column"):
                listener.enterSingle_column(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSingle_column"):
                listener.exitSingle_column(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitSingle_column"):
                return visitor.visitSingle_column(self)
            else:
                return visitor.visitChildren(self)




    def single_column(self):

        localctx = MySQLParser.Single_columnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_single_column)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self.match(MySQLParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multi_columnContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Multi_columnContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i=None):
            if i is None:
                return self.getTokens(MySQLParser.ID)
            else:
                return self.getToken(MySQLParser.ID, i)

        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(MySQLParser.COMMA)
            else:
                return self.getToken(MySQLParser.COMMA, i)

        def getRuleIndex(self):
            return MySQLParser.RULE_multi_column

        def enterRule(self, listener):
            if hasattr(listener, "enterMulti_column"):
                listener.enterMulti_column(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitMulti_column"):
                listener.exitMulti_column(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitMulti_column"):
                return visitor.visitMulti_column(self)
            else:
                return visitor.visitChildren(self)




    def multi_column(self):

        localctx = MySQLParser.Multi_columnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_multi_column)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 85
            self.match(MySQLParser.ID)
            self.state = 88 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 86
                self.match(MySQLParser.COMMA)
                self.state = 87
                self.match(MySQLParser.ID)
                self.state = 90 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==MySQLParser.COMMA):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class All_columnContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.All_columnContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ASTERISK(self):
            return self.getToken(MySQLParser.ASTERISK, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_all_column

        def enterRule(self, listener):
            if hasattr(listener, "enterAll_column"):
                listener.enterAll_column(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAll_column"):
                listener.exitAll_column(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitAll_column"):
                return visitor.visitAll_column(self)
            else:
                return visitor.visitChildren(self)




    def all_column(self):

        localctx = MySQLParser.All_columnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_all_column)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 92
            self.match(MySQLParser.ASTERISK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Where_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Where_clauseContext, self).__init__(parent, invokingState)
            self.parser = parser

        def hash_expression(self):
            return self.getTypedRuleContext(MySQLParser.Hash_expressionContext,0)


        def hash_range_expression(self):
            return self.getTypedRuleContext(MySQLParser.Hash_range_expressionContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_where_clause

        def enterRule(self, listener):
            if hasattr(listener, "enterWhere_clause"):
                listener.enterWhere_clause(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitWhere_clause"):
                listener.exitWhere_clause(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitWhere_clause"):
                return visitor.visitWhere_clause(self)
            else:
                return visitor.visitChildren(self)




    def where_clause(self):

        localctx = MySQLParser.Where_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_where_clause)
        try:
            self.state = 96
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 94
                self.hash_expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 95
                self.hash_range_expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Hash_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Hash_expressionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(MySQLParser.WHERE, 0)

        def hash_key(self):
            return self.getTypedRuleContext(MySQLParser.Hash_keyContext,0)


        def relational_op(self):
            return self.getTypedRuleContext(MySQLParser.Relational_opContext,0)


        def hash_value(self):
            return self.getTypedRuleContext(MySQLParser.Hash_valueContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_hash_expression

        def enterRule(self, listener):
            if hasattr(listener, "enterHash_expression"):
                listener.enterHash_expression(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitHash_expression"):
                listener.exitHash_expression(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitHash_expression"):
                return visitor.visitHash_expression(self)
            else:
                return visitor.visitChildren(self)




    def hash_expression(self):

        localctx = MySQLParser.Hash_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_hash_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self.match(MySQLParser.WHERE)
            self.state = 99
            self.hash_key()
            self.state = 100
            self.relational_op()
            self.state = 101
            self.hash_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Hash_range_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Hash_range_expressionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(MySQLParser.WHERE, 0)

        def hash_key(self):
            return self.getTypedRuleContext(MySQLParser.Hash_keyContext,0)


        def relational_op(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(MySQLParser.Relational_opContext)
            else:
                return self.getTypedRuleContext(MySQLParser.Relational_opContext,i)


        def hash_value(self):
            return self.getTypedRuleContext(MySQLParser.Hash_valueContext,0)


        def expr_op(self):
            return self.getTypedRuleContext(MySQLParser.Expr_opContext,0)


        def range_key(self):
            return self.getTypedRuleContext(MySQLParser.Range_keyContext,0)


        def range_value(self):
            return self.getTypedRuleContext(MySQLParser.Range_valueContext,0)


        def getRuleIndex(self):
            return MySQLParser.RULE_hash_range_expression

        def enterRule(self, listener):
            if hasattr(listener, "enterHash_range_expression"):
                listener.enterHash_range_expression(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitHash_range_expression"):
                listener.exitHash_range_expression(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitHash_range_expression"):
                return visitor.visitHash_range_expression(self)
            else:
                return visitor.visitChildren(self)




    def hash_range_expression(self):

        localctx = MySQLParser.Hash_range_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_hash_range_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 103
            self.match(MySQLParser.WHERE)
            self.state = 104
            self.hash_key()
            self.state = 105
            self.relational_op()
            self.state = 106
            self.hash_value()
            self.state = 107
            self.expr_op()
            self.state = 108
            self.range_key()
            self.state = 109
            self.relational_op()
            self.state = 110
            self.range_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Hash_keyContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Hash_keyContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MySQLParser.ID, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_hash_key

        def enterRule(self, listener):
            if hasattr(listener, "enterHash_key"):
                listener.enterHash_key(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitHash_key"):
                listener.exitHash_key(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitHash_key"):
                return visitor.visitHash_key(self)
            else:
                return visitor.visitChildren(self)




    def hash_key(self):

        localctx = MySQLParser.Hash_keyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_hash_key)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112
            self.match(MySQLParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Range_keyContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Range_keyContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MySQLParser.ID, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_range_key

        def enterRule(self, listener):
            if hasattr(listener, "enterRange_key"):
                listener.enterRange_key(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRange_key"):
                listener.exitRange_key(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitRange_key"):
                return visitor.visitRange_key(self)
            else:
                return visitor.visitChildren(self)




    def range_key(self):

        localctx = MySQLParser.Range_keyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_range_key)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self.match(MySQLParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Hash_valueContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Hash_valueContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MySQLParser.ID, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_hash_value

        def enterRule(self, listener):
            if hasattr(listener, "enterHash_value"):
                listener.enterHash_value(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitHash_value"):
                listener.exitHash_value(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitHash_value"):
                return visitor.visitHash_value(self)
            else:
                return visitor.visitChildren(self)




    def hash_value(self):

        localctx = MySQLParser.Hash_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_hash_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116
            self.match(MySQLParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Range_valueContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Range_valueContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MySQLParser.ID, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_range_value

        def enterRule(self, listener):
            if hasattr(listener, "enterRange_value"):
                listener.enterRange_value(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRange_value"):
                listener.exitRange_value(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitRange_value"):
                return visitor.visitRange_value(self)
            else:
                return visitor.visitChildren(self)




    def range_value(self):

        localctx = MySQLParser.Range_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_range_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 118
            self.match(MySQLParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Insert_valueContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Insert_valueContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MySQLParser.ID, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_insert_value

        def enterRule(self, listener):
            if hasattr(listener, "enterInsert_value"):
                listener.enterInsert_value(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInsert_value"):
                listener.exitInsert_value(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitInsert_value"):
                return visitor.visitInsert_value(self)
            else:
                return visitor.visitChildren(self)




    def insert_value(self):

        localctx = MySQLParser.Insert_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_insert_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 120
            self.match(MySQLParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Limit_valueContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Limit_valueContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(MySQLParser.ID, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_limit_value

        def enterRule(self, listener):
            if hasattr(listener, "enterLimit_value"):
                listener.enterLimit_value(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLimit_value"):
                listener.exitLimit_value(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitLimit_value"):
                return visitor.visitLimit_value(self)
            else:
                return visitor.visitChildren(self)




    def limit_value(self):

        localctx = MySQLParser.Limit_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_limit_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self.match(MySQLParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Relational_opContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Relational_opContext, self).__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(MySQLParser.EQ, 0)

        def LTH(self):
            return self.getToken(MySQLParser.LTH, 0)

        def GTH(self):
            return self.getToken(MySQLParser.GTH, 0)

        def NOT_EQ(self):
            return self.getToken(MySQLParser.NOT_EQ, 0)

        def LET(self):
            return self.getToken(MySQLParser.LET, 0)

        def GET(self):
            return self.getToken(MySQLParser.GET, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_relational_op

        def enterRule(self, listener):
            if hasattr(listener, "enterRelational_op"):
                listener.enterRelational_op(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRelational_op"):
                listener.exitRelational_op(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitRelational_op"):
                return visitor.visitRelational_op(self)
            else:
                return visitor.visitChildren(self)




    def relational_op(self):

        localctx = MySQLParser.Relational_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_relational_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 124
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MySQLParser.EQ) | (1 << MySQLParser.LTH) | (1 << MySQLParser.GTH) | (1 << MySQLParser.NOT_EQ) | (1 << MySQLParser.LET) | (1 << MySQLParser.GET))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expr_opContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Expr_opContext, self).__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(MySQLParser.AND, 0)

        def XOR(self):
            return self.getToken(MySQLParser.XOR, 0)

        def OR(self):
            return self.getToken(MySQLParser.OR, 0)

        def NOT(self):
            return self.getToken(MySQLParser.NOT, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_expr_op

        def enterRule(self, listener):
            if hasattr(listener, "enterExpr_op"):
                listener.enterExpr_op(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitExpr_op"):
                listener.exitExpr_op(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitExpr_op"):
                return visitor.visitExpr_op(self)
            else:
                return visitor.visitChildren(self)




    def expr_op(self):

        localctx = MySQLParser.Expr_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_expr_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 126
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << MySQLParser.AND) | (1 << MySQLParser.OR) | (1 << MySQLParser.XOR) | (1 << MySQLParser.NOT))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Between_opContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Between_opContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BETWEEN(self):
            return self.getToken(MySQLParser.BETWEEN, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_between_op

        def enterRule(self, listener):
            if hasattr(listener, "enterBetween_op"):
                listener.enterBetween_op(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBetween_op"):
                listener.exitBetween_op(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitBetween_op"):
                return visitor.visitBetween_op(self)
            else:
                return visitor.visitChildren(self)




    def between_op(self):

        localctx = MySQLParser.Between_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_between_op)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self.match(MySQLParser.BETWEEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Is_or_is_notContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(MySQLParser.Is_or_is_notContext, self).__init__(parent, invokingState)
            self.parser = parser

        def IS(self):
            return self.getToken(MySQLParser.IS, 0)

        def NOT(self):
            return self.getToken(MySQLParser.NOT, 0)

        def getRuleIndex(self):
            return MySQLParser.RULE_is_or_is_not

        def enterRule(self, listener):
            if hasattr(listener, "enterIs_or_is_not"):
                listener.enterIs_or_is_not(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIs_or_is_not"):
                listener.exitIs_or_is_not(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitIs_or_is_not"):
                return visitor.visitIs_or_is_not(self)
            else:
                return visitor.visitChildren(self)




    def is_or_is_not(self):

        localctx = MySQLParser.Is_or_is_notContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_is_or_is_not)
        try:
            self.state = 133
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 130
                self.match(MySQLParser.IS)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 131
                self.match(MySQLParser.IS)
                self.state = 132
                self.match(MySQLParser.NOT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





